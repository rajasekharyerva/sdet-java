ğ‘ğšğ­ğ ğ‹ğ¢ğ¦ğ¢ğ­ğ¢ğ§ğ : APIs often have rate #limits to prevent abuse.
Automation scripts can simulate excessive requests and validate the APIâ€™s response when the limit is exceeded.
Example: Sending more than 100 #requests in a minute and checking if the response returns 429 Too Many Requests.

1.1 ğ€ğ®ğ­ğ¡ğğ§ğ­ğ¢ğœğšğ­ğ¢ğ¨ğ§: Testing scenarios where users login via OAuth, JWT, or other mechanisms.
Example: Validating token-based #authentication for different user roles using automation scripts in Selenium or Cypress.
1.2 ğ€ğ®ğ­ğ¡ğ¨ğ«ğ¢ğ³ğšğ­ğ¢ğ¨ğ§: Verifying that only users with the correct permissions can access certain APIs.
Example: #Automating role-based access tests, ensuring unauthorized users receive proper error messages.
2. ğƒğğ©ğ¥ğ¨ğ²ğ¦ğğ§ğ­ ğ’ğ­ğ«ğšğ­ğğ ğ¢ğğ¬:
->ğğ¥ğ®ğ-ğ†ğ«ğğğ§ ğƒğğ©ğ¥ğ¨ğ²ğ¦ğğ§ğ­: Two environments (Blue and Green) are maintained.
The new version is deployed to the #inactive environment, and traffic is switched only after successful testing.
Example: Switch from Blue (live) to Green (new version) with zero downtime.
- >ğ‚ğšğ§ğšğ«ğ² ğƒğğ©ğ¥ğ¨ğ²ğ¦ğğ§ğ­: Gradually roll out a new version to a subset of users while monitoring its #performance.
If stable, the update is rolled out to the rest.
Example: Release the update to 10% of users, monitor, and expand if no issues arise.
- >ğ‘ğ¨ğ¥ğ¥ğ¢ğ§ğ  ğƒğğ©ğ¥ğ¨ğ²ğ¦ğğ§ğ­: Incrementally replace the old #version with the new one across servers, ensuring no downtime but slower rollouts.
Example: Update 20% of servers at a time, ensuring minimal impact.
- >ğ‘ğğœğ«ğğšğ­ğ ğƒğğ©ğ¥ğ¨ğ²ğ¦ğğ§ğ­: The current version is fully taken down before deploying the new one.
Simple but involves #downtime.
Example: Take down the app, deploy the new version, and bring it back online.
- >ğ€/ğ ğ“ğğ¬ğ­ğ¢ğ§ğ : Similar to canary, but serves different user experiences (A and B) to compare #performance and user #feedback.
Example: Test new features on version B for a specific user group while keeping version A for

I recently had an interview for an SDET II role where I was asked some pretty challenging questions, particularly around API testing using the RestAssured framework. Here are a few questions that stood out:

1. How would you validate the dynamic structure of a Gmail API response where the number of unread emails varies?
For this question, I had to demonstrate how to handle a dynamic JSON response when the number of unread emails changes.
I used JsonPath in RestAssured to extract the count of unread emails dynamically and validate it with assertions.

1. How would you automate OAuth2 authentication for accessing Gmail APIs in your RestAssured tests?
I needed to explain how to automate the OAuth2 authentication process using RestAssured.
This included obtaining an access token, managing token expiration, and using it to authorize requests to Gmail's secure APIs.

1. How would you test the rate limits for Gmail API using RestAssured?
I was asked to describe how to test the rate limits of the Gmail API by simulating multiple rapid requests and detecting when the API starts returning a 429 Too Many Requests response.
I proposed implementing a loop to send multiple requests, checking for the 429 status code, and adjusting the request strategy accordingly.

1. How would you validate the content of an email message retrieved from Gmail using RestAssured?
For this one, I had to show how to extract the email body from a response using JsonPath and then validate its content against expected values, considering scenarios where the content might be encoded.

1. How can you ensure your tests are resilient to Gmail API changes, such as new fields being added to the response?
This question was about designing tests that are flexible and future-proof.
I discussed using JSON Schema validation with rest-assured-json-schema-validator to handle dynamic fields and maintain robust test coverage even when the API evolves.


