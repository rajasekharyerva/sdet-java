1. How does Javaâ€™s garbage collection mechanism work to manage memory efficiently?

ğ€ğ§ğ¬ğ°ğğ«: Javaâ€™s garbage collector automatically identifies and deallocates objects that are no longer in use to free up memory, ensuring optimised performance and preventing memory leaks.

2. Whatâ€™s the best approach to analyse the time and space complexity of an ğšğ¥ğ ğ¨ğ«ğ¢ğ­ğ¡ğ¦?

Answer: To analyse an algorithm's complexity:

Time Complexity: Count the number of basic operations as a function of input size (e.g., O(n), O(log n)).

Space Complexity: Measure the additional space needed relative to input size (e.g., O(1), O(n)).

3. Implement an LRU (Least Recently Used) cache. It should support two operations: get(key) and put(key, value).

ğ‘ğğªğ®ğ¢ğ«ğğ¦ğğ§ğ­ğ¬:

get(key): Returns the value if the key exists, otherwise returns -1.

put(key, value): Inserts or updates the key-value pair. If the cache reaches its capacity, remove the least recently used item.

ğˆğ§ğ©ğ®ğ­/ğğ®ğ­ğ©ğ®ğ­ ğ„ğ±ğšğ¦ğ©ğ¥ğ:

Input: LRUCache(2), put(1, 1), put(2, 2), get(1), put(3, 3), get(2)

Output: 1, -1 (as key 2 was evicted)

4. Given an array of integer nums and an integer target, return ğ¢ğ§ğğ¢ğœğğ¬ of the two numbers such that they add up to the target.

ğˆğ§ğ©ğ®ğ­/ğğ®ğ­ğ©ğ®ğ­ ğ„ğ±ğšğ¦ğ©ğ¥ğ:

Input: nums = [2, 7, 11, 15], target = 9

Output: [0, 1] (since nums[0] + nums[1] = 2 + 7 = 9)

5. Given a string containing (), {}, [], determine if the input string is valid. A string is valid if brackets close in the correct order.

ğˆğ§ğ©ğ®ğ­/ğğ®ğ­ğ©ğ®ğ­ ğ„ğ±ğšğ¦ğ©ğ¥ğ:

Input: "()[]{}"

Output: True

Input: "(]"

Output: False